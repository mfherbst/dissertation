\section{The need for a flexible quantum chemistry software platform}

% TODO Ideas of Tobias Setzer:
% Typical programs are ASCII-in -> ASCII-out
% An idea going in a similar direction is for example TURBOMOLE
%   -> apparently they have very modular modules, where the state of a compuation
%      is incoded in the file on a harddrive
%   -> issue is getting out of the TURBOMOLE ecosystem
% Actual analysis, which is not part of the program package is compartively difficult.
% Especially the transfer of data from one package to another is extremely tough.
%
% Molsturm:
%     fully dynamic, real-time analysis
%     future of molsturm: overcome software package boundaries
%     Journals: JCTC, JCP  (siehe turbomole jungs)
%
% Overall: Focus more on the advantages of the package architecture

% Flexible and fair comparison

% TODO copy -> build into this section
Most existing quantum-chemistry packages
are built around a 
particular basis function type: either Gaussians,
Slaters, or numerical orbitals. This is hard-coded 
deeply in the programs, which are usually enormous
projects written in  highly optimized \cpp or \fortran.
This makes experimentation with different and more physically
appropriate basis functions exceedingly difficult:
even when all electronic integrals have been worked out,
adapting an existing quantum chemistry code to use
them is a daunting project.
% end copy

Especially the very different structure of the Fock matrix for
different discretisations (compare fig.\vref{fig:StructureFiniteElementFock},
\vref{fig:StructureGaussianFock} and \vref{fig:StructureSturmianFock})
makes it very hard to combine all different kinds of discretisations
in the same program.

\todoil{Decide on one of them}
The name \molsturm origates from \textbf{mol}ecular \textbf{sturm}ians
or \textbf{mo}dular and \textbf{l}azy with \textbf{sturm}ians.




\subsection{Basis-function independence and hot-swapping}
Conceptionally an SCF algorithm is entirely independent of the type of basis function.
One could think of it very much as a numerical technique to solve
an non-linear eigenvalue problem by linearisation.
Once the SCF orbitals have been obtained,
the remainder of a calculation (\eg a Post-HF method)
can be formulated entirely in the SCF orbital basis
and without any reference to the underlying type of basis functions.
As such it should be possible to design a quantum chemistry package,
which apart from the integral backend itself is entirely independent
of the basis function types which are implemented.

Achieving this has several advantages.
First of all it naturally implies that trying out some new basis functions is very easy,
since most of the code already exists and can be reused.
Just the integral computation by itself needs to be adapted.
Secondly comparing different basis function types can occur in a fair setting,
since for all types of basis functions the algorithms are optimised to a similar level.
Thirdly it even allows for a fair comparison between different integral backends,
\eg different GTO libraries.

Last but not least the ability to treat different kinds of basis functions
in the same framework simplifies the construction of hybrid basis sets,
where possibly numerical basis functions and GTOs or STOs are combined.
Similarly one could employ the strengths of multiple backends for the same type of basis function
in the sense that one mixes and matches different backends such that one can exploit
the advantages of both implementations best.

This works since at the level of the SCF all basis function types and backends
share exactly the same common interface,
which facilitates combinations between them.

% why is basis function independence useful
% how lazy matrices help here
% Also discuss hybrid basis sets
%% Coulomb Sturmians with (hot-swappable with Gaussians)

\subsection{Rapid development of new QM algorithms}
\todoil{Mention other python effords like SecondQuatizationAlgebra, pyscf, PyQuante,
python backends ins psi4 or GPAW ??}
% Covered in the related work
% refer downwards?

In the early stages of developing a new quantum-chemical algorithms
it is often not clear how well these algorithms perform
or if they even meet the expected requirements.
Before worrying about making the algorithm fast,
one first wants to know whether it even works.
For this a light-weight framework which possesses the flexibility
to quickly combine or amend the already implemented
functionality is very important.
Furthermore well-documented and open interfaces
as well as compliance with the available standards
allow easy integration of other frameworks to extend
the functionality of a package even beyond the scope
which was intended in the first place.
\todoil{Define rapid development better or leave the term "RAD" out?}
% leave the term out.

The \python interface of molsturm for example is deliberately designed
with simplicity in mind.
The downside is that many potential symmetries when storing the data
cannot be exploited,
but on the upside we managed to integrate \molsturm
with some third-party Post-HF libraries rather quickly.
For example the Full-CI interface to \pyscf was realised in only two days,
but still is general enough to work for Sturmians GTOs and theoretically
all basis function types which are implemented in our integral backend.
\todoil{Change to also mention CC if we get there}
In another proof-of-concept project of ours we just managed to
implement ADC(2)-x on top of \molsturm in less than 10 days in \python.

The careful reader might have noticed that a well-designed interface
might not only facilitate rapid development of new algorithms
but also prevent one from the need to re-implement the wheel
and much rather exploit the code which has already has been written
for one's purposes.

% why do we want that?
% what is rapid development
%    design of prototype to explore
%    tests to fixate the requirements
%    iterative update of the prototype to get to the final program
%
% Rapid development techniques require a flexible platform
% well-documented and open interfaces
% compliance to standards and easy integration with other frameworks


% phd should not spend a year to implement something which might not work
% need flexiblity to try things
% code should be easy and close to the physical formulae
%
% We no not want to re-implement the wheel -> integrate with what exists

% ADCman, MP2 
% Full CI (two days of work), PySCF
% ADC example? (ADCman)
% Can we do CC (PySCF)?


% Programmable from Python 
% PyADC [Proof of concept, done in 10 days]
% PyADC+Bohrium [Automatic parallel on CPU, GPU. Work in progress]

\subsection{Automated visualization and data analysis}
\todoil{This paragraph is about the user perspective. Make this more clear}
A large part of the everyday work in quantum chemistry
is the analysis of data which is generated by quantum-chemical programs.
Naturally when investigating a research question it is often
hard to tell what angle is needed to explain what is going on
before doing any preliminary analysis.
In other words the process of understanding what is going on is iterative
and usually supporting calculations and further modelling
needs to be done once more about the problem is known.

\todoil{Reword. This is not the best phrasing}
Therefore a flexible quantum-chemical framework allows to
easily amend calculations which have already been done
at a later stage, making maximal use of what is already known.
Surely in many cases where a more accurate method (e.g. CCSD) is employed
on top of preliminary results (e.g. MP2),
the cost of re-computing the preliminary result is negligible.
In some cases, however,
where the further investigation just involves obtaining
extra quantities like some density plots or similar,
it is rather unnecessary to run the same calculation again,
just because some parameters to request such properties
have been forgotten in the first instance.
Many quantum chemistry packages therefore allow
some mechanism to reuse previous results.
In some cases these mechanism can be rather inconvenient, however.

Furthermore the analysis of obtained data should be easily scriptable.
Most quantum chemistry programs produce human-readable plain-text output
for this very reason.
By the means of standard unix tools like \texttt{grep}, \texttt{awk},
\texttt{bash} or \python or similar those files are then parsed and
the data post-processed.
An alternative and in our opinion more advantageous approach
would be to instead offer a scriptable interface to control
the program package by itself,
along with some utility functions to print summaries
or plot results interactively.
This way results are fully available for a user to analyse
and he himself can decide what information to look at
and what not.
By the means of utility functions
archiving results as well as standard analysis
like printing summary information or plotting some orbitals or densities
should be easy.

Note that on the one hand gives the user much more flexiblity and control
what to look at,
but on the other hand still does not prevent the traditional
mechanism of converting the results into a human-readable output file
by the means of a simple wrapper script.

Especially the ability to archive a large portion of the calculation
furthermore allows to exploit previous results when performing
further calculations as well as delaying the analysis
to a later point when \eg more knowledge about the
problem has been obtained to decide what exactly to look at.
