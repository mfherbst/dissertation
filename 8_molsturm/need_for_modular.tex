\section{The need for a flexible quantum chemistry software platform}

% TODO Ideas of Tobias Setzer:
% Typical programs are ASCII-in -> ASCII-out
% An idea going in a similar direction is for example TURBOMOLE
%   -> apparently they have very modular modules, where the state of a compuation
%      is incoded in the file on a harddrive
%   -> issue is getting out of the TURBOMOLE ecosystem
% Actual analysis, which is not part of the program package is compartively difficult.
% Especially the transfer of data from one package to another is extremely tough.
%
% Molsturm:
%     fully dynamic, real-time analysis
%     future of molsturm: overcome software package boundaries
%     Journals: JCTC, JCP  (siehe turbomole jungs)
%
% Overall: Focus more on the advantages of the package architecture

% Flexible and fair comparison

% TODO copy -> build into this section
Most existing quantum-chemistry packages
are built around a 
particular basis function type: either Gaussians,
Slaters, or numerical orbitals. This is hard-coded 
deeply in the programs, which are usually enormous
projects written in  highly optimized \cpp or \fortran.
This makes experimentation with different and more physically
appropriate basis functions exceedingly difficult:
even when all electronic integrals have been worked out,
adapting an existing quantum chemistry code to use
them is a daunting project.
% end copy

Especially the very different structure of the Fock matrix for
different discretisations (compare fig.\vref{fig:StructureFiniteElementFock},
\vref{fig:StructureGaussianFock} and \vref{fig:StructureSturmianFock})
makes it very hard to combine all different kinds of discretisations
in the same program.

\todoil{Decide on one of them}
The name \molsturm origates from \textbf{mol}ecular \textbf{sturm}ians
or \textbf{mo}dular and \textbf{l}azy with \textbf{sturm}ians.




\subsection{Basis-function independence and hot-swapping}
Conceptionally an SCF algorithm is entirely independent of the type of basis function.
One could think of it very much as a numerical technique to solve
an non-linear eigenvalue problem by linearisation.
Once the SCF orbitals have been obtained,
the remainder of a calculation (\eg a Post-HF method)
can be formulated entirely in the SCF orbital basis
and without any reference to the underlying type of basis functions.
As such it should be possible to design a quantum chemistry package,
which apart from the integral backend itself is entirely independent
of the basis function types which are implemented.

Achieving this has several advantages.
First of all it naturally implies that trying out some new basis functions is very easy,
since most of the code already exists and can be reused.
Just the integral computation by itself needs to be adapted.
Secondly comparing different basis function types can occur in a fair setting,
since for all types of basis functions the algorithms are optimised to a similar level.
Thirdly it even allows for a fair comparison between different integral backends,
\eg different GTO libraries.

Last but not least the ability to treat different kinds of basis functions
in the same framework simplifies the construction of hybrid basis sets,
where possibly numerical basis functions and GTOs or STOs are combined.
Similarly one could employ the strengths of multiple backends for the same type of basis function
in the sense that one mixes and matches different backends such that one can exploit
the advantages of both implementations best.

This works since at the level of the SCF all basis function types and backends
share exactly the same common interface,
which facilitates combinations between them.

% why is basis function independence useful
% how lazy matrices help here
% Also discuss hybrid basis sets
%% Coulomb Sturmians with (hot-swappable with Gaussians)

\subsection{Rapid development of new QM algorithms}
\todoil{Mention other python effords like SecondQuatizationAlgebra, pyscf, PyQuante,
python backends ins psi4 or GPAW ??}
% Covered in the related work
% refer downwards?

In the early stages of developing a new quantum-chemical algorithms
it is often not clear how well these algorithms perform
or if they even meet the expected requirements.
Before worrying about making the algorithm fast,
one first wants to know whether it even works.
For this a light-weight framework which possesses the flexibility
to quickly combine or amend the already implemented
functionality is very important.
Furthermore well-documented and open interfaces
as well as compliance with the available standards
allow easy integration of other frameworks to extend
the functionality of a package even beyond the scope
which was intended in the first place.
\todoil{Define rapid development better or leave the term "RAD" out?}
% leave the term out.

The \python interface of molsturm for example is deliberately designed
with simplicity in mind.
The downside is that many potential symmetries when storing the data
cannot be exploited,
but on the upside we managed to integrate \molsturm
with some third-party Post-HF libraries rather quickly.
For example the Full-CI interface to \pyscf was realised in only two days,
but still is general enough to work for Sturmians GTOs and theoretically
all basis function types which are implemented in our integral backend.
\todoil{Change to also mention CC if we get there}
In another proof-of-concept project of ours we just managed to
implement ADC(2)-x on top of \molsturm in less than 10 days in \python.

The careful reader might have noticed that a well-designed interface
might not only facilitate rapid development of new algorithms
but also prevent one from the need to re-implement the wheel
and much rather exploit the code which has already has been written
for one's purposes.

% why do we want that?
% what is rapid development
%    design of prototype to explore
%    tests to fixate the requirements
%    iterative update of the prototype to get to the final program
%
% Rapid development techniques require a flexible platform
% well-documented and open interfaces
% compliance to standards and easy integration with other frameworks


% phd should not spend a year to implement something which might not work
% need flexiblity to try things
% code should be easy and close to the physical formulae
%
% We no not want to re-implement the wheel -> integrate with what exists

% ADCman, MP2 
% Full CI (two days of work), PySCF
% ADC example? (ADCman)
% Can we do CC (PySCF)?


% Programmable from Python 
% PyADC [Proof of concept, done in 10 days]
% PyADC+Bohrium [Automatic parallel on CPU, GPU. Work in progress]

\subsection{Automated visualization and data analysis}
\todoil{This paragraph is about the user perspective. Make this more clear}
A large part of the everyday work in quantum chemistry
is the analysis of data which is generated by quantum-chemical programs.
Naturally when investigating a research question it is often
hard to tell what angle is needed to explain what is going on
before doing any preliminary analysis.
In other words the process of understanding what is going on is iterative
and usually supporting calculations and further modelling
needs to be done once more about the problem is known.

\todoil{Reword. This is not the best phrasing}
Therefore a flexible quantum-chemical framework allows to
easily amend calculations which have already been done
at a later stage, making maximal use of what is already known.
Surely in many cases where a more accurate method (e.g. CCSD) is employed
on top of preliminary results (e.g. MP2),
the cost of re-computing the preliminary result is negligible.
In some cases, however,
where the further investigation just involves obtaining
extra quantities like some density plots or similar,
it is rather unnecessary to run the same calculation again,
just because some parameters to request such properties
have been forgotten in the first instance.
Many quantum chemistry packages therefore allow
some mechanism to reuse previous results.
In some cases these mechanism can be rather inconvenient, however.

Furthermore the analysis of obtained data should be easily scriptable.
Most quantum chemistry programs produce human-readable plain-text output
for this very reason.
By the means of standard unix tools like \texttt{grep}, \texttt{awk},
\texttt{bash} or \python or similar those files are then parsed and
the data post-processed.
An alternative and in our opinion more advantageous approach
would be to instead offer a scriptable interface to control
the program package by itself,
along with some utility functions to print summaries
or plot results interactively.
This way results are fully available for a user to analyse
and he himself can decide what information to look at
and what not.
By the means of utility functions
archiving results as well as standard analysis
like printing summary information or plotting some orbitals or densities
should be easy.

Note that on the one hand gives the user much more flexiblity and control
what to look at,
but on the other hand still does not prevent the traditional
mechanism of converting the results into a human-readable output file
by the means of a simple wrapper script.

Especially the ability to archive a large portion of the calculation
furthermore allows to exploit previous results when performing
further calculations as well as delaying the analysis
to a later point when \eg more knowledge about the
problem has been obtained to decide what exactly to look at.


%%%% new intro
% -> some of this could go to the actual intro
Even though computational electronic structure theory
has been a very active field of research since the 1930s
the fundamental question, which type of functions
are best used for a numerical treatment of the
electronic wave function, has still not yet been answered conclusively.
Most available program packages for performing
quantum-chemical calculations nevertheless focus
solely on methodologies based on
the linear combination of Gaussian-shaped atomic orbital functions.
One may rationalise this predominance
by the pragmatic historic developments
taking place in the founding years of modern electronic structure theory%
~\cite{Boys1950, Hehre1969}.
Most notably it was realised that the electron-repulsion integrals
of Gaussian-type orbitals~(GTOs) are computationally
much more feasible than the physically more exact
exponential-shaped Slater-type orbitals~(STOs)~\cite{Slater1930}.
This set off many developments
both in terms of efficient algorithms as well as methodologies
centered around GTOs,
making approaches based on GTOs widely applicable
for simulating electronic structures.

Nevertheless it is a well-known fact
that even contracted GTOs are not able to represent
all features of the electron density well.
Most prominently they fail to describe the nuclear cusp as well as
the exponential decay of the electron density~\cite{Kato1957}.
Whilst in most practical use cases one is able to compensate
by employing specialised Gaussian basis sets~\cite{Jensen2013,Hill2013},
there are strong hints that the accurate computation of properties
like NMR shielding tensors~\cite{Guell2008,Hoggan2009}
requires a correct description of the core-like region or the tail, too.
\todoil{James: Will you put in more references to PF Loos
and the guys doing the ionising Sturmian properties here.}

It should not come as a surprise that numerous research groups
have looked into alternative basis function types.
Next to plane-waves or projector-augmented wave methods%
~\cite{Kresse1996,Kresse1999,Mortensen2005,Enkovaara2010}
so-called numerical basis functions~\cite{Frediani2015}
have become popular in the recent years as well.
Examples for such efforts would be the use of wavelets%
~\cite{Bischoff2011,Bischoff2012,Bischoff2013,Bischoff2014,Bischoff2014a,Bischoff2017}
or finite elements%
~\cite{Tsuchida1995,Soler2002,Lehtovaara2009,Alizadegan2010,Avery2011PhD,Davydov2015,Boffi2016},
just to name a few.
With our \molsturm package we want to support such research directions
by providing a program package
which offers a common platform for developing, testing and analysing
quantum-chemical methods irrespective of the basis function type employed for
the discretisation.

With respect to this, the name ``\molsturm'' is misleading
as the package did outgrow its original purpose to support
\textbf{mol}ecular calculations with so-called \textbf{Sturm}ian-type
basis functions.
The simplest representative of the latter type of functions
are the Coulomb-Sturmians~(CS)~\cite{Shull1959,Rotenberg1962,Rotenberg1970}.
These can be formally obtained as the isoenergetic solutions
$\varphi^\text{CS}_{nlm}$ to a hydrogenic Schrödinger-like equation
\begin{equation}
	\left( \Delta + \frac{k n}{r} - E \right) \varphi^\text{CS}_{nlm}(\vec{r}) = 0.
	\label{eqn:CS}
\end{equation}
Their functional form is
\begin{equation}
	\varphi^\text{CS}_{nlm}(\vec{r}) = P_{nl}(r) \exp(- k r) Y_{lm}\left(\vec{r} / r \right),
	\label{eqn:CSProduct}
\end{equation}
\ie a product of a particular polynomial $P_{nl}$,
an exponential and a spherical harmonic.
The structure of these functions is very similar compared to STOs
with the important difference that the parameter $k$ is identical for
all functions of the basis set.
On the one hand this allows to reformulate the computation
of the electron-repulsion integrals in a rather efficient way%
~\cite{Avery2011PhD,Avery2011}.
On the other hand this similarity permits such a basis to simultaneously
represent the long-range tail and the nuclear cusp physically
if the $k$ is chosen appropriately,
which makes them rather promising.
While Coulomb-Sturmians are only applicable for simulating atoms,
a range of more generalised Sturmian-type basis functions exist%
~\cite{Avery2011},
where efficient algorithms for evaluating the repulsion integrals
have been published recently~\cite{Avery2006,Avery2015,Morales2016,Avery2017}.
\todo[inline]{James: Add citations for the ionising Sturmians.}

\begin{figure}
	\centering
	\missingfigure{Instead of having the figures here,
	refer to fig. \vref{fig:StructureFiniteElementFock}, \vref{fig:StructureGaussianFock}
	and \vref{fig:StructureSturmianFock}}
	%
	\caption{
		Structure of the Fock matrix for the beryllium atom
		in a restricted Hartree-Fock self-consistent field procedure
		employing in each case the indicated basis function type
		for the discretisation.
		%
		The colour of a pixel represents the logarithm
		of the absolute value of the appropriate matrix element
		according to the scale given on the right hand side.
		%
		In each case the matrices are shown early in the self-consistent
		field procedure with a Pulay error Frobenius norm larger than 0.1.
	}
	\label{fig:FockStructure}
\end{figure}

For a thorough investigation of such new types of basis functions
both the implementation of the algorithms computing
the one-electron and electron-repulsion integrals
as well as a systematic comparison
with already existing basis function types is required.
This can either be achieved by writing a separate program,
which has the disadvantage that well-established algorithms
for all kinds of quantum-chemistry methods need to be re-implemented
in the new setting.
On the other hand one may also implement
the new routines into the framework of an already existing
electronic structure theory code.
Since most existing codes
are built around only one particular basis function type
and are highly optimised for the numerical requirements
of this particular basis,
implementing a new basis function type can become a daunting task.

To illustrate this latter point let us consider
the usual ansatz of solving the Hartree-Fock~(HF) equations
in a self-consistent field~(SCF) procedure.
Fig.~\ref{fig:FockStructure} shows the structure of the Fock matrix
arising if various basis function types are employed for the discretisation.
Whilst the 
Coulomb-Sturmian and Gaussian matrices are almost
diagonal dominant, even almost strictly diagonal dominant,
about half the rows in the finite-element matrix
sum to more than twice the diagonal,
i.e. violate the condition for diagonal dominance.
On the other hand the finite-element matrix is more sparse,
but also much larger than the other two types of matrices.
One should mention that the finite-element discretisation depicted here
is still far too inaccurate to yield a sensible description
of the Beryllium atom density.
A realistic description would need in the order of $10^5$ to $10^6$ basis
functions, see \eg reference \cite{Davydov2015}.

As a result of these structural differences
the required numerical algorithms for a
diagonalisation of these matrices differ as well.
In fact for finite-element methods subspace-based, iterative
algorithms like Arnoldi~\cite{Arnoldi1951} or Davidson~\cite{Davidson1975}
iteration are typically employed for diagonalisation.
Recent advances in this field have developed these algorithms
further to so-called matrix-free methods~\cite{Kronbichler2012},
which avoid building the diagonalised matrix in memory at all.
Instead one only passes an \emph{expression} for the
computation of the matrix-vector product to the eigensolver.
Since such expressions may involve arbitrary tensor contractions,
like the ones occurring in the computation of the
exchange part of the Fock matrix,
we will refer to such methods
by the term \contraction-based methods.

In many cases \contraction-based approaches
have more advantages than saving memory.
For both finite elements as well as for Coulomb-Sturmians
for example a \contraction-based ansatz
allows to reformulate the matrix-vector product in a way
that the computational complexity is reduced.
An important point to note is that
a \contraction-based diagonalisation algorithm
does not prevent one from building the matrix in memory still.
As such it is not only favourable for the aforementioned
types of functions,
but it furthermore leads to no disadvantages
for diagonalising a Fock matrix originating from
a contracted Gaussian basis set.

Considering the flexibility which results from such approaches,
they are a perfect ingredient for
a quantum-chemical method development framework
supporting the numerical requirements of various types of basis functions.
Such a framework has been missing up to today to the best of our knowledge.

This paper presents our new \molsturm quantum-chemistry framework.
We do not only implement our \contraction-based SCF scheme
in such a way that the code is fully agnostic to the type of basis function used,
but we furthermore provide a powerful \python interface.
By means of the latter obtaining, archiving and analysing results
is easy and can be fully automatised
as will be demonstrated in section \ref{sec:examples}.

Once the SCF orbitals have been obtained,
the remainder of a calculation, \eg a Post-HF method,
can be formulated entirely in the SCF orbital basis
and without any reference to the underlying basis functions.
Therefore a basis-function independent SCF scheme automatically
leads to basis-function independent Post-HF methods as well.
In fact the aforementioned \python interface of \molsturm
makes it easy to re-use existing software modules
together with \molsturm's SCF.
In this manner we have already managed to link \molsturm to \pyscf~\cite{Sun2017}
for performing full configuration interaction~(FCI) calculations employing any of the
basis function types implemented in \molsturm.
Similarly a link between \molsturm and \adcman~\cite{Wormit2014}
for computing excited state energies at ADC(2),
ADC(2)-x and ADC(3)~\cite{Schirmer1982,Trofimov1999} level
has been established.
\molsturm is open-source and can be obtained from \url{https://molsturm.org}.

%The next section of the paper will briefly review
%a few of the already existing projects with similar goals than \molsturm.
%In section \ref{sec:design} we will discuss how \molsturm's design
%yields a basis-function independent SCF code,
%which is easily extended by new types of basis functions or
%computational back ends.
%Section \ref{sec:examples} shows a couple of examples how \molsturm's
%\python interface can be used in practice for automated processing
%of repetitive quantum-chemical calculations or to implement new methods.
%Section \ref{sec:state} gives an idea into the current state of
%\molsturm and what we hope to achieve in the future.
%Finally section \ref{sec:conclusion} discusses and concludes
%the ideas we present.
%%% end new intro

